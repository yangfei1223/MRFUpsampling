function result = MRFUpsamplingTensor(tensor,depth,sigma,alpha)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Function Name: MRFUpsamplingTensor
%Aim: Solve the large sparse linear system generated by incorporating tensor into the MRF upsamling model
%Output: 
%   Result      -   the output depth data
%Input: 
%   Image       -   Input color image
%   depth       -   Depth map need upsampling
%   sigma       -   Coefficient of gaussian kernel for tensor similarity
%   alpha       -   The balance factor between data term and smoothness term
%Code Author:
%   Liu Junyi, Zhejiang University
%   June 2012
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
    height = size(tensor,1);
    width = size(tensor,2);
    pixelNumber = height * width;
    
    %Depth Matrix - N*1
    depth = double(depth);
    Z = sparse(reshape(depth,pixelNumber,1));
    
    %Data Term Matrix - N*N
    x = find(reshape(depth,pixelNumber,1)>0);
    y = x;
    s = 1;
    W = sparse(x,y,s,pixelNumber,pixelNumber);
    
    %Smoothness Term Matrix - 4N*N, Here we exclude the pixels on the boundary
%     S=sparse((width-2)*(height-2)*4,PixelNumber);
    
    %Compute the smoothness matrix
    tic;
    x=zeros(1,(width-2)*(height-2)*8);
    y=zeros(1,(width-2)*(height-2)*8);
    s=zeros(1,(width-2)*(height-2)*8);
    for j=2:width-1      %Regardless of boundary
        for i=2:height-1     %Regardless of boundary 
            X = tensor{i,j};
            Y1 = tensor{i,j-1}; %Left
            Y2 = tensor{i,j+1}; %Right
            Y3 = tensor{i-1,j}; %Up
            Y4 = tensor{i+1,j}; %Down
            w(1)=exp(-1/(2*sigma^2)*(sqrt(log(det((X+Y1)/2))-1/2*log(det(X*Y1)))).^2);  %Weight Factors 1: with left point
            w(2)=exp(-1/(2*sigma^2)*(sqrt(log(det((X+Y2)/2))-1/2*log(det(X*Y2)))).^2);  %Weight Factors 2: with right point
            w(3)=exp(-1/(2*sigma^2)*(sqrt(log(det((X+Y3)/2))-1/2*log(det(X*Y3)))).^2);  %Weight Factors 3: with upper point
            w(4)=exp(-1/(2*sigma^2)*(sqrt(log(det((X+Y4)/2))-1/2*log(det(X*Y4)))).^2);  %Weight Factors 4: with lower point

            Pos=(4*((height-2)*(j-2)+i-2));
            x(2*Pos+1:2*Pos+4)=Pos+1:Pos+4;
            y(2*Pos+1:2*Pos+4)=(height*(j-1)+i)*[1 1 1 1];
            s(2*Pos+1:2*Pos+4)=w';
            x(2*Pos+5:2*Pos+8)=Pos+1:Pos+4;
            y(2*Pos+5:2*Pos+8)=[height*(j-2)+i height*j+i height*(j-1)+i-1 height*(j-1)+i+1];
            s(2*Pos+5:2*Pos+8)=-w';   
        end
    end
    S = sparse(x,y,s,(width-2)*(height-2)*4,pixelNumber);
    SmoothnessTime=toc;
    fprintf('    The running time of generating the pairwise matrix is %.5f s\n',SmoothnessTime)
    
    %Compute the A and b
    tic;
    A1 = S'*S;
    A2 = W'*W;
    A = alpha*A1 + A2;
    b = W'*W*Z;
    fprintf('    The running time of getting A and b is %.5f s\n',toc)
    
     %Using Backslash to solve the Ax=b
    tic;
    Result = A\b;
    fprintf('    The running time of solving Ax=b by Backslash is %.5f s\n',toc)
    
    result = full(reshape(double(Result),height,width));
    fprintf('    Done!\n')
end
